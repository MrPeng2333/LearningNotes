# Golang

## 基础知识

### hello_world

- 怎样设置环境变量？

	- 设置【GOPATH】环境变量，在【1.8】版本之前必须设置，之后的版本不设置会使用默认值，Mac上通过修改【～/.bash_profile】来设置

- 应用程序入口？

	- 必须是【main】包：【package main】
	- 必须是【main()】方法：func main()
	- 文件名不一定是【main.go】

- 【main()】函数特点？

	- 不支持任何返回值，通过【os.Exit()】来返回状态
	- 不支持传入参数 ，通过【os.Args】来获取命令行参数

### 变量

- 编写测试程序的文件、方法命名？

	- 源码文件以【_test】结尾：xxx_test.go
	- 测试方法名以【Test】开头：func TestXXX(t *testing.T){...}

- 声明变量的方法有哪些？

	- var <name> <type>：初始化时若赋值可省略变量类型，Go会根据【=】右值推导出变量类型

		- 若不指定类型声明变量，即显式初始化，若【=】右值为小数，变量类型会定为float64，大多数情况下不需要这么高的精度，推荐指定类型float32

	- var (<name> <type> <br>....)：多个变量一起声明
	- <name> := <value>：声明并初始化一个变量，Go根据右值推导其类型，这种方式只能用于函数内部
	- <name1>, <name2> := <value1>, <value2>：声明并初始化多个变量，此方式可用于交换变量值（a, b = b, a）

- 常量快速设置连续值？

	- const (Monday = iota + 1 Tuesday Wednsday)
	- const (Open = 1 << iota Close Pending)

- 如何声明常量？

	- const <name> <type>
	- const {<name> <type> ...}

- 什么是隐式初始化、显式初始化？

	- 定义变量时若没有赋值，Go就会自动对其初始化，这就是隐式初始化，反之就是显式初始化

- 各类型的隐式初始化值？

	- string为空字符串
	- int为0
	- float为0.0
	- bool为false
	- 指针类型为nil

- 什么是指针变量？

	- 指针变量就是存储变量地址的变量
	- 普通变量存储的是值，指针变量存储的是地址

- 什么是匿名变量？

	- 也成占位符或空白标识符，用下划线表示

- 匿名变量的优点？

	- 不分配内存，不占用内存空间
	- 不需要为无用变量命名而烦恼
	- 多次声明不会有任何问题

- 怎样定义指针变量？

	- var ptr = &var_name
	- var ptr = new(type)：此方式会创建一个type类型的匿名变量，初始化为type类型的零值，然后返回变量的地址，返回的指针类型为【*type】

- 类型转换与其他语言的区别？

	- 不支持隐式类型转换，即小类型赋值给大类型时自动转换类型
	- 甚至不支持别名类型到原类型的转换

- 指针类型与其他语言的区别？

	- 不能进行指针运算，比如通过指针自增来访问连续的数组值

### 运算符

- 使用【==】比较数组的条件及比较结果？

	- 条件：相同维数且元素个数相同的数组才能比较
	- 结果：数组中每个元素都相同时才相等

- 什么是【&^】运算符？

	- 按位置零运算符
	- 运算符右数二进制位上为1，则无论对应左数二进制位上是啥，结果都为0；运算符右数二进制位为0，则左数对应二进制位原来是什么就是什么

### 数据类型

- 整型的分类？

	- int（取决于操作系统的位数）、int8、int16、int32、int64；uint（取决于操作系统的位数）、uint8、uint16、uint32、uint64
	- int和uint的区别在于有无符号位，uint只能表示正整数

- 不同进制的表示方法？

	- 二进制：0b或0B为前缀
	- 八进制：0o或0O为前缀
	- 十六进制：0x为前缀

- 浮点数的精度是多少？

	- float32精度为小数点后6位
	- float64精度位小数点后15位

- 浮点数的最大值如何表示？

	- "math.MaxFloat32"

		- 引号是由于OPML无法转换添加的

	- "math.MaxFloat64"

- byte类型？

	- 与uint8类型没有区别，占一个字节，能表示0到255，表示的是ASCII字符的一个字符

- rune类型？

	- 与int32类型没有区别，表示的是一个Unicode字符

- 字符与字符串的区别？

	- 形式上字符用单引号，字符串用双引号
	- 字符实质上一个整数

- 字符串（string）的表示方法？

	- 双引号表示，此时【\r\n】等有特殊含义的转义符需要【\\r\\n】表示
	- 反引号表示，此时【\r\n】直接表示即可，所见即所得

- string与其他语言的差异？

	- string是数据类型，不是引用或指针类型
	- string是只读的【byte slice】，【len】函数可以计算它所包含的【byte】数
	- string的【byte】数组可以存放任何数据
	- 未赋值的string变量其值不是【nil】，而是空字符串

- 什么是【unicode】和【UTF8】？

	- Unicode是一种字符集（code point）
	- UTF8是unicode的存储实现（转换为字节序列的规则）

- 声明数组的方法？

	- var <arr_name> [size]<type>
	- var <arr_name> [size]<type> = [size]<type>{v1, ... , v_size}
	- <arr_name> := [size]<type>{v_1, ... , v_size}
	- <arr_name> := [...]<type>{v_1, ...}：使用【...】代替具体的size，解除硬编码
	- <arr_name> := [size]<type>{index : value}：除了【index】位置的值以外其余都默认为0值

- 怎样声明多维数组？

	- 声明并初始化：arr := [2][2]int{{1, 2}, {3, 4}}

- 怎样为类型定义别名？

	- 类型别名也成类型字面量
	- type <alias_name> <type>
	- 类型也包括方法签名

- 切片的内部结构？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211020001247.png)
	- 【ptr】指向一片连续的内存空间

- 怎样截取数组？

	- 左闭右开：arr[s : e]
	- arr[s : e : last]：last指的是e的值最多到last

- 切片的声明方式？

	- var <name> []<type>
	- var <name> = []<type>{}：空切片
	- var <name> := make([]<type>, size, cap)：使用make函数构造切片，【cap】参数可以省略，省略后和【size】大小一致
	- <name> := []<type>{index : value}：此时切片的【size】和【cap】都和【index】一致，除【index】位置的值以外，都是零值

- 切片容量（【cap】）扩展的方式？

	- 添加元素容量不够时，容量以两倍增加

- 切片的共享存储？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211020081548.png)
	- 此时，共享存储的两个切片，一个切片的值改变，另一个也会改变

- 切片与数组的区别？

	- 容量是否可以伸缩
	- 是否可以进行比较

- 【append()】方法的使用？

	- 追加一个元素：myarr = append(myarr, 2)
	- 追加多个元素：myarr = append(myarr, 3, 4)
	- 追加一个切片：myarr = append(myarr, []int{7, 8}...)
	- 在第一个位置插入元素：myarr = append([]int{0}, myarr...)
	- 在中间插入一个切片：myarr = append(myarr[:5], append([]int{5,6}, myarr[5:]...)...)

- 声明初始化【map】的方法？

	- var scores map[string]int = map[string]int{"english": 80, "chinese": 85}：若只是声明没有赋值，则必须使用【make()】函数初始化后才能赋值，类似于Java引用类型必须先new才能赋值
	- scores := map[string]int{"english": 80, "chinese": 85}
	- scores := make(map[string]int, <cap>)

- 怎样删除字典值？

	- delete(dict_name, key)
	- key不存在时不会报错

- 怎样添加字典值？

	- dict_name[key] = value

- 访问不存在的字典值会报错吗？

	- 不会，会返回value-type的零值

- 怎样判断字典的key是否存在？

	- 字典的下标读取可以返回两个值，第二个值即表示对应的key是否存在（true/false）

- 怎样循环字典？

	- for subject, score := range scores {}
	- for subject := range scores {}
	- for _, score := range scores {}

- 【map】与工厂模式？

	- 【map】的【value】可以是一个方法
	- 与Go的Dock type接口方式一起，可以方便的实现单一对象的工厂模式
	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211020090955.png)

- map实现set基本功能？

	- Go没有内置Set，可以使用map[int]bool{}来实现set的一些基本功能

- bool类型的一些特点？

	- true/false同1/0不一致
	- 逻辑取反使用【!】

- 指针的创建方法？

	- 使用【&】获取变量的地址赋给指针变量
	- 先使用【new】方法创建指针（ptr := new(type)），分配内存，再往对应内存地址中赋值（*ptr = value）
	- 声明一个指针（var <ptr_name> *<type>），再将其他变量的地址赋给指针变量

- 怎样通过函数改变数组的值？

	- 传递数组的切片
	- 传递数组的指针

### 流程控制

- Go中的流程控制方法有哪些？

	- if-else条件语句
	- switch-case选择语句
	- for-range循环语句
	- goto无条件跳转语句
	- defer延迟执行

- if-else条件语句中对花括号的要求？

	- Go要求else if或else 要和两边的花括号在同一行

- if的高级写法？

	- if可以先写一个表达式，取得变量后，再对其进行判断，中间用分号隔开

- switch-case语句的特点？

	- 一个case后可以接多个条件，用逗号隔开，条件之间是或的关系
	- case后的条件常量只能出现一次
	- switch后可接函数
	- switch后可不接表达式，不接时就相当于if-else if-else
	- case中使用【fallthrough】关键字时会直接执行下一个case的语句而不判断条件

- switch条件与其他语言的区别？

	- 条件表达式不限制为常量或者整数
	- 单个【case】中，可以出现多个结果选项，使用逗号分隔
	- 不需要【break】明确退出一个【case】
	- 可以不设定【switch】之后的表达式，这种情况下，整个【switch】结构与多个【if...else...】的逻辑作用相同

- for循环的几种格式？

	- for a <= 5 {}
	- for i := 1; i <= 5; i++ {}
	- for {}：无限循环，使用break和continue语句控制循环
	- for _, item := range myarr {}：range会返回索引和数据，所以用不到的索引可以用占位符接收

- goto语句是什么？

	- goto后接一个标签，然后跳转到标签位置处（后接冒号）继续执行

- goto语句注意事项？

	- goto与标签之间不能有变量声明

- defer语句的作用及使用方式？

	- defer后面接一个函数的调用，实现将这个函数的调用延迟到当前函数结束之后

- defer语句的特点？

	- defer的函数调用传递的参数，并不会收到当前函数后面语句的影响，但如果defer后面跟的是匿名函数，则会接收最后的变量值
	- 一个函数里多次调用defer，最后这些defer是以类似栈的方式反序调用defer的
	- defer在return之后执行

- 为什么要有defer？

	- 在需要释放资源的情况中，没有defer时需要每次在return时调用一次释放资源的代码，使用defer语句只需要调用一次代码就可以了

### 异常机制

- 什么是panic?

	- panic用于不可以恢复的错误
	- panic退出前会执行defer指定的内容

- panic VS os.Exit？

	- os.Exit退出时不会调用defer指定的函数
	- os.Exit退出时不输出当前调用栈信息

- recover怎样使用？

	- recover只能在defer域中使用，在其他地方是不工作的
	- recover函数能够捕捉panic的信息作为返回值返回
	- recover函数的目的在于在程序宕机前对程序做一些处理（保存某些信息等）

- recover使用不当产生的问题？

	- 形成僵尸服务进程（活着但不提供服务），导致health check失效
	- “Let it Crash”往往是恢复不确定性错误的最好方法

- panic和recover函数的特点？

	- 调用panic函数宕机后，只会执行当前协程的defer

- Go的错误机制与其他语言的差异？

	- 没有异常机制
	- 【error】类型实现了【error】接口
	- 可以通过【errors.New】来快速创建错误实例

### 语句块与作用域

- 什么是显示语句块？

	- 用花括号括起来的一系列语句

- 什么是隐式语句块？

	- 就是在隐式语句块这个区域中，其声明的变量的作用域就只在该区域

- 隐式语句块有哪些？

	- 主语句块：包括所有源码，对应内置作用域
	- 包语句块：包括该包中所有的源码（一个包可能会包括一个目录下的多个文件），对应包级作用域
	- 文件语句块：包括该文件中的所有源码，对应文件级作用域
	- for 、if、switch等语句本身也在它自身的隐式语句块中，对应局部作用域

- 四种作用域？

	- 内置作用域：不需要自己声明，所有的关键字和内置类型、函数都拥有全局作用域
	- 包级作用域：必須函数外声明，在该包内的所有文件都可以访问
	- 文件级作用域：不需要声明，导入即可。一个文件中通过import导入的包名，只在该文件内可用
	- 局部作用域：在自己的语句块内声明，包括函数，for、if 等语句块，或自定义的 {} 语句块形成的作用域，只在自己的局部作用域内可用

- 作用域的特点？

	- 低层作用域可以访问高层作用域
	- 同一层作用域相互隔离
	- 低层作用域声明的变量会覆盖高层作用域声明的变量

- 静态作用域与动态作用域？

	- 静态作用域就是变量的作用范围不变，动态作用域会在某种情况下改变，比如shell语言

### 函数

- 函数与其他语言的区别？

	- 可以有多个返回值
	- 所有参数都是值传递：slice、map、channel会有传引用的错觉
	- 函数可以作为变量的值
	- 函数可以作为参数和返回值

- 可变参数格式？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211021075320.png)

## 面向对象

### 对象

- 怎样定义结构体？

	- type <struct_name> struct { <attr_name> <attr_type>...}
	- 相邻属性类型相同可以合并在一起写

- 怎样声明结构体变量？

	- a := Student { name : "Dale",...}
	- 最后一个属性和右花括弧不在同一行时，【,】不能省略，反之就可以省略
	- 字段名要么全写，要么全不写
	- 初始化结构体时，未赋值的字段自动赋予类型零值

- 什么是绑定方法？

	- Go的结构体内是不能声明方法的，Go通过一种将结构体实例与方法绑定的方式类似的实现结构体方法，在方法内部可以访问绑定实例的属性

- 绑定方法的两种方式？

	- func (e Employee) String() string {}：这种定义方式在实例对应方法被调用时，实例成员会进行值复制
	- func (e *Employee) String() string {}：这种定义方法可以避免内存拷贝，在方法中修改实例值会影响到实例

- Go如何实现继承？

	- Go是不支持继承的，Go可以通过结构体间的组合来实现继承
	- 在一个定义结构体时，将另一个结构体作为一个匿名字段，这样就拥有了另一个结构体的全部属性

- 匿名结构体嵌套的方法访问优先级？

	- 优先自身结构体的方法，自身结构体方法能够调用嵌套结构体的方法，嵌套结构体的方法不能调用自身结构体的方法

- Go怎样实现方法的权限控制？

	- 当方法首字母大写时，该方法对所有的包都是public的
	- 当首字母小写时，这个方法是private的，其他包没法任意调用

- 三种实例化方法？

	- 正常实例化
	- 使用new：xm := new(Profile)
	- 使用&：var xm *Profile = &Profile{}

- 什么是选择器？

	- 从结构体对象中取得属性值，使用【.】操作符，这个操作符就是选择器

- 选择器的一个妙用？

	- 当对象是结构体指针时，想要取得这个对象的属性值，正常情况需要【*】取值，而我们可以省去这一步操作，因为选择器【.】能够直接解引用

- 怎样定义接口？

	- type Phone interface {call()}

- 怎样实现接口？

	- 一个类型/结构体实现了接口的全部方法，就称这个类型/结构体实现了该接口

- 什么是接口？

	- 在Go中，接口就是方法签名的集合

- 怎样定义tag？

	- Tag 由反引号包含，由一对或几对的键值对组成，通过空格来分割键值

- 怎样获取字段？（反射）

	- field := reflect.TypeOf(obj).FieldByName("Name")
	- field := reflect.ValueOf(obj).Type().Field(i) // i 表示第几个字段
	- field := reflect.ValueOf(&obj).Elem().Type().Field(i) // i 表示第几个字段

- 怎样获取tag？

	- 先获取对应的字段field
	- tag := field.tag

- 怎样获取tag的键值对？（在获取到tag后）

	- labelValue := tag.Get("label")
	- labelValue,ok := tag.Lookup("label")
	- Get是对LookUp的简单封装，没有结果时返回空字符串

- 什么是tag？

	- 在结构体中，每个字段都由名字和字段类型组成，除此之外还可以加一个属性，用反引号包起来的字符串，称之为tag，也就是标签

### 接口

- 什么是空接口？

	- 空接口是特殊形式的接口，它不包含任何方法
	- 接口有两个属性，一个是类型，一个是值，空接口两者都是【nil】

- 怎样使用空接口？

	- 使用【interface{}】作为类型声明一个实例，这个实例可以承载任意类型的值
	- 使用空接口作为函数的参数，可以让函数接收任意类型的值。接收任意个任意类型的值：【paras ...interface{}】

		- 使用空接口接收任意类型的参数时，它的静态类型是【interface{}】，动态类型未知，需要使用类型断言才能判断

	- 声明接收任意类型的array、slice、map、struct

		- 空接口承接数组或切片后，该对象无法再进行切片

- 什么是类型断言？

	- 英文名：Type Assertion
	- 它可以检查【i】是否为【nil】；检查【i】存储的值是否为某个类型

- 类型断言的使用方式？

	- 【t := i.(T)】：可以断言一个接口对象【i】是不是【nil】，并且接口对象【i】存储的值类型为【T】，断言成功返回其值，失败出发【panic】
	- 【t, ok := i.(T)】：断言成功时，返回其值，【ok】值为【true】；断言失败不会出发【panic】，而是将【ok】值为【false】，【t】为零值

- 【type switch】断言如何使用？

	- 【switch x := i.(type) { case int:...}】

- 类型断言注意项？

	- 仅能对静态类型为空接口【interface{}】的对象进行断言

- 接口的三个“潜规则”？

	- 对方法调用的限制：接口变量不能调用接口中未声明的方法
	- 调用函数时的隐式转换：函数调用都是值传递的，变量会在方法调用前进行类型转换
	- 类型断言中的隐式转换：断言完成后，会返回一个静态类型为你断言类型的对象

- 怎样显示转换为接口类型？

	- 【b := interface{}(a)】

- Go接口与其他语言的区别？

	- 接口为非入侵性的，实现不依赖于接口定义
	- 所以接口的定义可以包含在接口使用者包内

- 实例对象赋值给自己所实现的接口的变量时需要注意什么？

	- 只能使用实例的指针赋值给接口变量，包括传参是也只能传递指针类型

- Go接口的最佳实践（怎样设计接口）？

	- 倾向使用小接口定义，很多接口只包含一个方法
	- 较大的接口定义，由多个小接口定义组合而成
	- 只依赖于必要功能的最小接口

### 反射

- 什么是反射？

	- 为了区分变量值类型，将反射前环境称为“真实世界”，反射后环境称为“反射世界”，这只是一种比喻
	- “反射世界”中，可以获取一个对象的类型、属性及方法的能力

- 两种类型【Type】和【Value】？

	- 在“反射世界”中，【reflect.Type】、【reflect.Value】（在【reflect包中】）两种类型是整个反射的核心，对应着“真实世界”的【type】和【value】
	- 源码上，【reflect.Type】以接口形式存在；【reflect.Value】以结构体形式存在，并且接收了很多方法
	- “真实世界”里，【type】和【value】一起组成接口变量；“反射世界”里，【type】和【value】是分开的，由【reflect.Type】和【reflect.Value】来表现

- 反射三定律？

	- 反射可以将接口类型变量转换为“反射类型对象”
	- 反射可以将“反射类型对象”转换为接口类型变量
	- 如果要修改“反射类型对象”，其类型必须是可写的

- 怎样实现接口变量到反射对象的转换？

	- 【reflect.TypeOf(i)】：获取接口值的类型
	- 【reflect.ValueOf(i)】：获取接口值的值
	- 两个方法接收的是【interface{}】类型
	- 两个方法返回的对象，称之为反射对象

- 怎样实现反射对象到接口变量的转换？

	- 【i := v.Interface()】
	- 【reflect.Value】的结构体会接收【Interface()】方法，返回一个【interface{}】类型的变量
	- 只有【Value】才能逆向转换，【Type】不能

- 怎样检测反射对象是否可以修改？（具有【可写性】）

	- 使用【reflect.TypeOf()】、【reflect.ValueOf()】时接收的不是接口变量的指针，反射世界的变量值只是真实世界的拷贝，不是接收变量指针创建的反射对象，是不具备【可写性】的
	- 是否具备【可写性】可以用【CanSet()】来获取得知
	- 对不具备【可写性】的反射对象进行修改，是不合法的，回报错

- 使反射对象具备【可写性】需要注意？

	- 创建反射对象时传入变量的指针
	- 使用【Elem()】函数返回指针指向的数据

- 如何修改具有【可写性】反射对象的值？

	- 通过【Set】单词开头的方法修改

- 怎样使用获取类别函数【Kind()】？

	- 【Kind()】可以获取反射对象对应的接口变量的基础类型
	- 【Kind】和【Type】是有区别的，【Kind】表示更基础、范围更广的分类，通过源码可以得知其表示的都是Go原生的基本类型（25种合法类型），不包含自定义类型
	- 【Type】和【Value】对象都可以使用【Kind()】方法

- 反射对象类型转换函数？

	- 【Int()】
	- 【Float()】
	- 【String()】
	- 【Bool()】
	- 【Pointer()】
	- 【Interface()】

- 反射对象对切片的操作？

	- 【Slice()】【Slice3()】：对切片再切片，返回的还是反射对象
	- 【Set()】【Append()】：更新切片

- 反射对象对属性的操作？

	- 【NumField()】【Field()】

- 反射对象对方法的操作？

	- 【NumMethod()】【Method()】：要获取【Name】，注意使用【reflect.TypeOf()】
	- 【v.Method(i).Call(nil)】：动态调用函数，使用索引且无参数注意使用【ValueOf()】
	- 【v.MethodByName(<method_name>).Call(nil)】：动态调用函数，使用函数名无参数
	- 【v.MethodByName(<method_name>).Call(intput)】：动态调用函数，使用函数名有参数，【input】为反射对象类型切片，包含调用方法的所有参数

### 静态类型与动态类型

- 什么是静态类型？

	- 静态类型就是变量声明时候的类型，编码时肉眼可见的类型

- 什么是动态类型？

	- 程序运行时系统才能看见的类型，比如空接口【interface{}】

- 接口的两种类型？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211015101548.png)
	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211015101734.png)

- 反射的必要性？

	- 由于动态类型的存在，在一个函数中接收的参数类型无法预先知晓，此时需要对参数进行反射，然后根据不同的类型做不同的处理

### 关键字make和new

- new函数？

	- 只能传递一个参数，为任意类型
	- new函数做的事情：分配内存；设置零值；返回指针

- make函数？

	- 用来为slice、map或chan类型分配内存和初始化一个对象
	- 不返回指针，返回值依赖于传入的类型
	- 这三种类型都是引用类型，所以需要初始化（size和cap），不是置为零值

### 空结构体

- 空结构体的妙用？

	- 空结构体是一个不占用空间的对象，这与它是否接收方法无关，在某些时候可以作占位符用，合理使用可以减少内存空间占用

## 项目管理

### 包

- 什么是包？

	- 基本复用模块单元：以首字母大写来表明可被包外代码访问（结构体、方法等）
	- 代码的【package】可以和所在目录不一致
	- 同一目录里的Go代码的【package】要保持一致

- 导入包的两种方式？

	- 单行导入：import "fmt"
	- 多行导入：import(...)

- 为包起别名的场景以及如何起别名？

	- 导入包名相同的两个包
	- 导入包名很长的包
	- 包名和本地变量起冲突
	- 【import <alias_name> <package_name>】

- 函数使用频繁的包如何直接使用其函数？

	- 【import . <package_name>】
	- 使用此方式可能导致导入包的函数和自己定义的函数冲突

- 包的初始化(【init()】方法)？

	- 在【main()】执行前，所有依赖的【package】的【init()】方法都会被执行
	- 不同包的【init()】方法按照包导入的依赖关系决定执行顺序
	- 在一个包引用链中，包的初始化是深度优先的
	- 每个包或源文件可以有多个【init】函数
	- 【init()】不能有入参和返回值
	- 【init()】不能被其他函数调用
	- 同一个包内多个【init()】的顺序是不受保证的
	- 在【init()】之前，会先初始化包内的常量和变量（常量先于变量）

- 包的匿名导入？

	- 导入的包未被使用编译是会报错的
	- 只使用导入包的【init()】函数使用匿名导入【import _ <package_name>】，下划线为空白标识符，不能被访问

- 导入的是路径还是包？

	- 导入的是路径，导入后可以使用该路径下的所有包

- 绝对导入和相对导入？

	- 在【Go 1.10】前不支持相对导入
	- 绝对导入：从【$GOPATH/src】或【$GOROOT】或者【$GOPATH/pkg/mod】目录下搜索包并导入
	- 从当前目录搜索包导入（使用相对目录）
	- 使用相对导入是，项目不能放在【$GOPATH/src】下
	- Go Modules 不支持相对导入，在你开启 GO111MODULE 后，无法使用相对导入

- 什么是【vendor】？

	- 【vendor】目录是通过【go mod vendor】命令生成的，这个命令会将项目依赖全部打包到你的项目目录下的【vendor】文件夹中

- 包导入优先级？

	- 使用【vendor】：先在【vendor】中找，然后在【$GOROOT/src】中找，最后在【$GOPATH/src】中找，都找不到就报错
	- 使用【modules】：先在【$GOPATH/pkg/mod】中找，然后导入包如果有域名就去网站中找，没有域名就去【$GOROOT】中找

- 怎样下载别人的包到本地？

	- 【go get -u github.com/easierway/concurrent_map】
	- 【-u】此参数表示运行此命令时抓取最新版本的包到本地，没有此参数则本地有包则不抓取

### Go Modules

- GOPATH组成？

	- 【bin】：存放编译后生成的二进制可执行文件
	- 【pkg】：存放编译后生成的【.a】文件
	- 【src】：存放项目的源代码，可以是你自己写的代码，也可以是你 go get 下载的包

- 什么是GOPATH模式？

	- 将你的包或者别人的包全部放在【$GOPATH/src】目录下进行管理的方式

- GOPATH模式未解决的依赖问题？

	- 同一环境下，不同项目使用同一包的不同版本
	- 无法管理对包的特定版本的依赖

- 为什么会有【go vendor】模式？

	- 解决【GOPATH】模式下不同项目无法使用多个版本库
	- 使用【GOPATH】模式，所有项目共享一个【GOPATH】，导入依赖时，都就来这里找，所以【GOPATH】模式下只能有一个版本的第三方库

- 什么是【go vendor】模式？

	- 在每个项目下创建【vendor】目录，项目所需要的依赖只会下载到自己的【vendor】目录下，项目之间依赖包互不影响
	- 在【Go 1.6】之前，需要手动设置环境变量

- 【vendor】模式下查找依赖包的目录顺序？

	- 当前包下的【vendor】目录
	- 向上级目录查找，知道找到【src】下的【vendor】目录
	- 在【GOPATH】下面查找依赖包
	- 在【GOROOT】目录下查找

- 依赖管理工具【gilde】的安装和使用？

	- 安装：【brew install glide】
	- 使用：到对应的项目下，打开终端，输入命令【glide init】，会生成【glide.yaml】文件，此时会将项目的依赖包写入此文件，再运行【glide install】命令，会在该目录下生成【vendor】目录，并将【glide.yaml】中依赖的网络包（本地包不会下载）下载到其中

- 怎样开启【go mod】模式？

	- 设置环境变量的值：【go env -w GO111MODULE="on/off/auto"】，其中【auto】为项目在【$GOPATH/src】外且项目根目录有【go.mod】文件时，自动开启模块支持

## 并发编程

### 协程机制

- 协程被系统中断提高并发能力的机制？

	- 当一个协程被系统中断，比如IO需要等待的时候，Processor会把自己移到另一个可使用的系统线程当中，继续执行它所挂的队列里的其他协程
	- 当中断的协程被唤醒，它会把自己加入到其中某一个Processor的协程等待队列里或全局等待队列当中
	- 当一个协程被中断时，它在寄存器的运行状态会保存到这个协程对象里，当协程重新获得运行机会时，这些状态又会重新写入寄存器，然后继续运行

- Thread VS Groutine?

	- 创建时默认的【stack】的大小：JDK5以后Java Thread stack默认为1M；Groutine的Stack初始化为2K
	- 和KSE（Kernel Space Entity）的对应关系：Java Thread是1:1；Groutine是M:N

- Groutine的调度机制？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211022161530.png)
	- Processor是Go实现协程处理器，每个Processor都有一个协程等待队列，也有一个在运行中的协程

- Groutine为什么在线程切换上比Thread效率高？

	- 由于Thread与KSE（系统线程）的对应关系为1:1，所以当Thread涉及切换时，KSE也会切换，这个切换的消耗很大
	- 而Groutine与KSE的对应关系为M:N，处在同一个KSE下的Groutine切换消耗是很小的

- Go怎样保证一个Groutine不会等待很长时间？

	- Go的守护线程有一个对每个Processor（Go语言实现的协程处理器）完成Groutine的计数，当一段时间后发现计数没有变化，就会往这个Groutine的任务栈添加一个特别的标记，当Groutine运行遇到非内联函数就会读到这个标记，就会把自己中断下来，等候队列的队尾，然后切换到别的协程继续运行

### 共享内存并发机制

- 为什么在多个协程中增加count的值得不到预期的值？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211023092931.png)
	- 在上述代码中，协程在执行时，先读取count再更新count，这个过程不具备原子性（同时完成）
	- 即当一个协程读取count值为100，还没有更新count，此时另一个协程读取到count的值为100并更新为101，此时还未更新值的进程开始更新count也是更新为101，所以count得不到预期的值

- 什么是互斥锁（Mutex）？

	- 互斥锁使得同一时刻仅能有一个协程能对锁住的内容操作

- 怎样添加互斥锁？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211023093757.png)

- 什么是WaitGroup？

	- WaitGroup用于等待指定的子协程完成后才结束当前协程，防止父协程执行过快，一些子协程没有执行完

- 怎样使用WaitGroup？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211023095145.png)

- 什么是读写锁（RWMutex）？

	- RWMutex将对资源的访问分为读操作和写操作，当有一个协程在对资源进行读操作时，写操作会阻塞
	- 当一个协程对资源进行写操作时，其他读操作和写操作都会阻塞
	- 当有多个读操作同时进行时，相互之间不会阻塞，也就是说当存在大量读操作时，使用RWMutex锁的效率比Mutex高

- 为什么go test测试输出结果没有变化以及解决方案？

	- 场景：使用go test进行测试，没有修改代码的情况下，重复多次测试，发现测试结果没有变化。如创建10个协程，5个读锁协程，5个写锁协程，输出的数据没有变化
	- 情况说明：从Go 1.10开始，成功的包的测试结果将被缓存
	- 解决方案：禁用缓存的命令【go test -v -count=1 go_file.go】，【-v】是配置测试时显示打印信息，vscode中在【settings.json】中添加【"go.testFlags":["-v", "-count=1"]】配置

### CSP并发机制

- 什么是CSP？

	- 英文全称：Communicating sequential process
	- 是指依赖于一个通道来完成两个通讯实体之间的协调

- CSP VS Actor Model？

	- 和Actor的直接通讯不同，CSP模式则是通过Channel进行通讯的，更松耦合一些
	- Go中channel是有容量限制并且独立处理Groutine，而如Erlang，Actor模式中的mailbox容量是无限的，接收进程也总是被动的处理信息

- Channel的机制？

	- 第一种机制：通讯的两方必须同时在channel上才能完成这次交互，任何一方不在的时候，另一方都会被阻塞在那里等待，直到另一方完成这个交互
	- 第二种机制（buffered channel）：给channel设定一个容量，在容量没有满之前放消息的人都是可以往里面放消息的，容量满了，就必须等待接收消息的拿掉一个消息，容量空出来，才能继续往通道放消息；对与接收消息的人来说，只要通道里有消息，就可以拿消息往下执行，如果没消息就必须等待，直到有消息才能往下执行

- 两种机制的Channel如何声明？

	- ch := make(chan string)
	- buffered channel：【ch := make(chan string, 2)】，【string】为通道存储的消息类型，【2】为缓冲区大小，省略是默认为【0】

- 怎样查看channel缓冲区大小？

	- 【cap(channel)】

### 多路选择和超时控制

- 什么是多路选择？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211024153458.png)
	- 每个case后面跟的都是一个阻塞事件，比如从一个channel上等待消息
	- 当运行select时，只要任一case后面阻塞事件处于非阻塞状态，就会运行case后面定义的语句
	- 当有多个非阻塞case时，运行case的选择与case的定义顺序无关
	- 当所有case都处于阻塞状态，就会执行default

- 什么是超时控制？

	- ![](https://gitee.com/mr-peng2333/image-storage/raw/master/img/20211024154312.png)
	- 当1秒过后，【retCh】通道还没有返回消息，就会执行第二个case
	- 超时控制就是防止一直等待通道消息

